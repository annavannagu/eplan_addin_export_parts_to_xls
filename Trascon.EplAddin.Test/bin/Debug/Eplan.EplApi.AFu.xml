<?xml version="1.0"?>
<doc>
    <assembly>
        "Eplan.EplApi.AF"
    </assembly>
    <members>
        <member name="M:Eplan.EplApi.ApplicationFramework.Internal.EplAddinLocator.GetModuleOfAssembly(System.Reflection.Assembly,System.String@)">
            <summary>
get the registered module name of this assembly 
</summary>
        </member>
        <member name="M:Eplan.EplApi.ApplicationFramework.Internal.EplAddinLocator.GetModuleOfAddin(Eplan.EplApi.ApplicationFramework.IEplAddIn,System.String@)">
            <summary>
get the registered module name of this IEplAddIn 
</summary>
        </member>
        <member name="M:Eplan.EplApi.ApplicationFramework.Internal.EplAddinLocator.RemoveFinder(Eplan.EplApi.ApplicationFramework.Internal.EventHandlerFindAddinModule)">
            <summary>
For internal use only. Remove when added before.
</summary>
        </member>
        <member name="M:Eplan.EplApi.ApplicationFramework.Internal.EplAddinLocator.AddFinder(Eplan.EplApi.ApplicationFramework.Internal.EventHandlerFindAddinModule)">
            <summary>
For internal use only. Add a finder when you can resolve the module name
</summary>
        </member>
        <member name="M:Eplan.EplApi.ApplicationFramework.BatchActionManager.ExecuteOnServer(System.String,System.String,System.String,Eplan.EplApi.ApplicationFramework.ActionCallingContext)">
            <summary>
Execute a batchable action on the server
</summary>
            <param name="strNameOfJob">
the display name of this job
</param>
            <param name="strProjectLinkFileName">
the project for this action. This is the complete link file name.
</param>
            <param name="strBatchInterfaceName">
the interface name of the IEplActionBatchExtension. This is the name of the 
Interface, p.e. "ActionSetPropOnAllPagesBatch"
</param>
            <param name="context">
the context for the action with all of the parameters.
</param>
            <returns>
true when executing (sending job) was successful
</returns>
        </member>
        <member name="T:Eplan.EplApi.ApplicationFramework.BatchActionManager">
            <summary>
Class for executing a batch action
</summary>
        </member>
        <member name="M:Eplan.EplApi.ApplicationFramework.ActionParameterProperties.Set(System.String)">
            <summary>
Sets name and description text of a parameter. 
</summary>
            <param name="strParamName">
Name of the parameter.
</param>
        </member>
        <member name="M:Eplan.EplApi.ApplicationFramework.ActionParameterProperties.Set(System.String,System.String)">
            <summary>
Sets name and description text of a parameter. 
</summary>
            <param name="strParamName">
Name of the parameter.
</param>
            <param name="strDescription">
Description text for the parameter.
</param>
        </member>
        <member name="P:Eplan.EplApi.ApplicationFramework.ActionParameterProperties.Description">
            <summary>
Description text of a parameter.
</summary>
        </member>
        <member name="P:Eplan.EplApi.ApplicationFramework.ActionParameterProperties.Name">
            <summary>
Name of a parameter.
</summary>
        </member>
        <member name="M:Eplan.EplApi.ApplicationFramework.ActionParameterProperties.GetAfActionParameter">
            <summary>
For internal use only. 
</summary>
            <returns>
For internal use only. 
</returns>
        </member>
        <member name="M:Eplan.EplApi.ApplicationFramework.ActionParameterProperties.Finalize">
            <summary>
Non-deterministic Finalizer of ActionParameterProperties object.
</summary>
        </member>
        <member name="M:Eplan.EplApi.ApplicationFramework.ActionParameterProperties.Dispose">
            <summary>
Destructor for deterministic finalization of ActionParameterProperties object.
</summary>
        </member>
        <member name="M:Eplan.EplApi.ApplicationFramework.ActionParameterProperties.#ctor(AfActionParameter*,System.Boolean)">
            <summary>
For internal use only. 
</summary>
            <param name="pAfActionParameter">
For internal use only. 
</param>
            <param name="bCopy">
For internal use only. 
</param>
        </member>
        <member name="M:Eplan.EplApi.ApplicationFramework.ActionParameterProperties.#ctor">
            <summary>
Creates a new instance. 
</summary>
        </member>
        <member name="T:Eplan.EplApi.ApplicationFramework.ActionParameterProperties">
            <summary>
\Description of a parameter that can be passed to an
ActionCallingContext. This class only serves for
documentation purposes.
</summary>
            <example>
\Example of listing action parameters
<code>
ActionManager oMng = <b>new</b> ActionManager();
Action oAction = oMng.FindAction(m_strActionName);
labelDescription.Text = oAction.ActionProperties.Description;

ArrayList lst= oAction.ActionProperties.GetParameterProperties();

<b>if</b> (lst.Count== 0)
{
   listViewParameter.Hide();
}
<b>else</b>
{
   <b>foreach</b> (ActionParameterProperties oProperties <b>in</b> lst)
   {
        String strParamName         = oProperties.Name;
        String strParamDescription  = oProperties.Description;

        System.Windows.Forms.ListViewItem listItem= <b>new</b> System.Windows.Forms.ListViewItem(strParamName);
        listItem.SubItems.Add(strParamDescription);

        listViewParameter.Items.Add(listItem);

    }
    listViewParameter.Show();
}
</code></example>
        </member>
        <member name="P:Eplan.EplApi.ApplicationFramework.License.Type">
            <summary>
Gets license type: local, remote (network) or borrowed.
</summary>
            <remarks>
If licensing is not initialized no license type will be returned. In this case the value LicenseType.NoLicense will be returned.
</remarks>
            <returns>
Type of the license currently in use.
</returns>
        </member>
        <member name="P:Eplan.EplApi.ApplicationFramework.License.DongleNumber">
            <summary>
Get the dongle number
</summary>
            <returns>
The dongle number of the computer
</returns>
        </member>
        <member name="M:Eplan.EplApi.ApplicationFramework.License.GetLicenseModules(System.Collections.Generic.Dictionary`2{Eplan.EplApi.ApplicationFramework.LicenseOptions,System.Boolean}@)">
            <summary />
            <param name="LicenseModulesDic">
A Dictionary of license modules.
</param>
            <returns>
A Dictionary of license modules.	The key is the license option of the module. the value is the state whether the
module license is available or not.
</returns>
        </member>
        <member name="M:Eplan.EplApi.ApplicationFramework.License.LockOption(Eplan.EplApi.ApplicationFramework.LicenseOptions)">
            <summary>
Assigns a license to an option on the system, i.e., a license for this option is deducted.  
If all available licenses for this option are already in use, the function fails.
An option is used until the program is exited.
</summary>
            <param name="eOption">
A license is assigned to this option.
</param>
            <returns>
true: A license has been successfully assigned to this option.
false: No license has been assigned to this option.
</returns>
        </member>
        <member name="M:Eplan.EplApi.ApplicationFramework.License.HasOption(Eplan.EplApi.ApplicationFramework.LicenseOptions)">
            <summary>
Is used to determine whether a license for this option exists in the system and if it is available.  
</summary>
            <param name="eOption">
Determines whether a license is available on the system for this licensing option.
</param>
            <returns>
true: This options is licensed on the system.
false: This options is not licensed on the system.
</returns>
        </member>
        <member name="M:Eplan.EplApi.ApplicationFramework.License.Finalize">
            <summary> 
Non-deterministic Finalizer of License object.
</summary>
        </member>
        <member name="M:Eplan.EplApi.ApplicationFramework.License.Dispose">
            <summary> 
Destructor for deterministic finalization of License object.
</summary>
        </member>
        <member name="T:Eplan.EplApi.ApplicationFramework.License">
            <summary>
Class for querying EPLAN licensing options (<see cref="T:Eplan.EplApi.ApplicationFramework.LicenseOptions" />).
</summary>
        </member>
        <member name="T:Eplan.EplApi.ApplicationFramework.LicenseType">
            <summary>
License type: local, network (remote) or borrowed
</summary>
        </member>
        <member name="T:Eplan.EplApi.ApplicationFramework.LicenseOptions">
            <summary>
License options provided by the EPLAN licensing system.
</summary>
        </member>
        <member name="F:Eplan.EplApi.ApplicationFramework.LicenseOptions.SchematicGenerator">
***
</member>
        <member name="F:Eplan.EplApi.ApplicationFramework.LicenseOptions.op_custom7">
***
</member>
        <member name="M:Eplan.EplApi.ApplicationFramework.ActionProperties.GetAfActionProp">
            <summary>
For internal use only. 
</summary>
            <returns>
For internal use only.                
</returns>
        </member>
        <member name="M:Eplan.EplApi.ApplicationFramework.ActionProperties.GetParameterProperties">
            <summary>
Returns all descriptions of the <seealso cref="T:Eplan.EplApi.ApplicationFramework.ActionParameterProperties" /> context parameters.
</summary>
            <returns>
List of description objects
</returns>
        </member>
        <member name="M:Eplan.EplApi.ApplicationFramework.ActionProperties.AddParameter(Eplan.EplApi.ApplicationFramework.ActionParameterProperties)">
            <summary>
Adds the description of another context parameter. 
</summary>
            <param name="oActionParameterProperties">
Description parameter to be added.
</param>
        </member>
        <member name="P:Eplan.EplApi.ApplicationFramework.ActionProperties.Description">
            <summary>
Description text for an action. 
</summary>
        </member>
        <member name="M:Eplan.EplApi.ApplicationFramework.ActionProperties.Finalize">
            <summary>
Non-deterministic Finalizer of ActionProperties object.
</summary>
        </member>
        <member name="M:Eplan.EplApi.ApplicationFramework.ActionProperties.Dispose">
            <summary>
Destructor for deterministic finalization of ActionProperties object.
</summary>
        </member>
        <member name="M:Eplan.EplApi.ApplicationFramework.ActionProperties.#ctor">
            <summary>
Creates an ActionProperties object.
</summary>
        </member>
        <member name="M:Eplan.EplApi.ApplicationFramework.ActionProperties.#ctor(AfActionProp*)">
            <summary>
For internal use only. 
</summary>
            <param name="pAfActionProp">
For internal use only.
</param>
        </member>
        <member name="T:Eplan.EplApi.ApplicationFramework.ActionProperties">
            <summary>
This class returns a description text and a list of the parameters
that can be passed as context parameters <see cref="!:ActionCallingContext" />.
</summary>
        </member>
        <member name="T:Eplan.EplApi.RemoteServer.IRemotingSynchronizer">
For internal use only.
Interface which must be implemented from a remote pre-server.
At the moment this interface is identical with IRemotePostServer. But it must not be so!
</member>
        <member name="T:Eplan.EplApi.RemoteServer.IRemotePostServer">
For internal use only.
Interface which must be implemented from a remote post-server.
</member>
        <member name="T:Eplan.EplApi.BaseRemoting._kResponse">
For internal use only.	
This enum defines possible responses of the Eplan remoting server.
</member>
        <member name="T:Eplan.EplApi.BaseRemoting._SynchronizationMode">
For internal use only.
</member>
        <member name="M:Eplan.EplApi.ApplicationFramework.IEplActionBatchExtension.GetSelectionParameter(System.Boolean,Eplan.EplApi.ApplicationFramework.ActionCallingContext)">
            <summary>
Get all parameter different for a project selection or a page selection
when 
</summary>
            <param name="bForProject">true: return the relevant parameter for COMPLETE project</param>
            <param name="pContext">add your parameter here</param>
            <returns>true if any parameter was added</returns>
        </member>
        <member name="M:Eplan.EplApi.ApplicationFramework.IEplActionBatchExtension.GetPageFilterParameterNameInContext">
            <summary>
Get the page filter parameter name of the Context. This one is replaced by the project on the server.
p.e. PAGEFILTERNAME
</summary>
            <returns>the string which represents the page filter name for the selection in the project</returns>
        </member>
        <member name="M:Eplan.EplApi.ApplicationFramework.IEplActionBatchExtension.GetPersistentParameters">
            <summary>
Fill all parameter names in the list which should be saved. They are saved in the scheme for
auto proc.
</summary>
            <returns>the list of parameters to remember in scheme for your dialog</returns>
        </member>
        <member name="M:Eplan.EplApi.ApplicationFramework.IEplActionBatchExtension.GetProjectParameterInContext">
            <summary>
Get the project parameter name of the Context. This one is replaced by the project on the server.
</summary>
            <returns>the string which represents the project full name</returns>
        </member>
        <member name="M:Eplan.EplApi.ApplicationFramework.IEplActionBatchExtension.GetBatchActionName">
            <summary>
Get the action this interface belongs to
</summary>
            <returns>the name of the action executed</returns>
        </member>
        <member name="M:Eplan.EplApi.ApplicationFramework.IEplActionBatchExtension.GetBatchActionDisplayName">
            <summary>
Get the display name of this action
</summary>
            <returns>the wanted name in the ui language</returns>
        </member>
        <member name="M:Eplan.EplApi.ApplicationFramework.IEplActionBatchExtension.GetListOfSettings">
            <summary>
Get all relevant Settings for this action to be able to execute this action on
oder computer and other user settings. 
</summary>
            <returns>the list. return null when no settings are needed.</returns>
        </member>
        <member name="M:Eplan.EplApi.ApplicationFramework.IEplActionBatchExtension.GetParameters(Eplan.EplApi.ApplicationFramework.ActionCallingContext)">
            <summary>
Get all parameters needed for this action. Set the needed parameters in the context.
Open a dialog to get the parameters from user.
</summary>
            <param name="pCallingContext">the context to add your parameter to</param>
            <returns>true: The action can continue its execution</returns>
        </member>
        <member name="M:Eplan.EplApi.ApplicationFramework.IEplActionBatchExtension.GetProjectRequirement">
            <summary>
Return the project handling for this action
</summary>
        </member>
        <member name="T:Eplan.EplApi.ApplicationFramework.ProjectOpenRequirement">
            <summary>
Interface to make an action batchable on a server. 
</summary>
            <example>
                <code lang="c#">
		class ActionSetPropOnAllPagesBatch : IEplActionBatchExtension, IInterface
		{
			/#region IEplActionBatchExtension Members

		// get the display name of this batch action. This is displayed in autoproc dialog.
		public string GetBatchActionDisplayName()
		{
			return "raise value of page property custom supplementaryfield 1";
		}

		// Get the name of the action to execute.
		public string GetBatchActionName()
		{
			return "ActionSetPropOnAllPages";
		}

		// get the parameters.
		// when a dialog should popup to ask the user for the parameters.
		// handling is stopped when false is returned.
		public bool GetParameters(ActionCallingContext pCallingContext)
		{
			string param1 = "";
			pCallingContext.GetParameter("param1", ref param1);
			string param2 = "";
			pCallingContext.GetParameter("param2", ref param2);
			bool bOk = InputBox.ShowInputBox(ref param1, ref param2);

			pCallingContext.AddParameter("param1", param1);
			pCallingContext.AddParameter("param2", param2);

			return bOk;
		}

		// Remember this params in script scheme. They are restored when reopeing a dialog
		public string[] GetPersistentParameters()
		{
			string[] strParamList = new string[2];
			strParamList[0] = "param1";
			strParamList[1] = "param2";
			return strParamList;
		}

		// return the needed Settings. Note: this settings has to exist on the client!
		// on server the settings are imported before the action is executed.
		public string[] GetListOfSettings()
		{
			string[] strSettingList = new string[2];
			strSettingList[0] = "User.Eplan@EplAddIn@MyAddIn10.param3";
			strSettingList[1] = "User.Eplan@EplAddIn@MyAddIn10.param4";
			return strSettingList;
		}
		// This param is used in scripts. The actual project will set to it.
		public string GetProjectParameterInContext()
		{
			return "ProjectName";
		}

		public ProjectOpenRequirement GetProjectRequirement()
		{
			return ProjectOpenRequirement.ProjectExclusive;
		}

			/#endregion

			/#region IInterface Members

		// AutoProcActionInterface is needed to attach to the autoproc dialog
		public string InterfaceName
		{
			get { return "ActionSetPropOnAllPagesBatch:AutoProcActionInterface"; }
		}

		/#endregion


		}
</code>
            </example>
            <summary>
This action requires the project in one of the following mode. 
</summary>
            <param name="ProjectReadOnly">Open the project read only</param>
            <param name="ProjectWritable">Open the project writable</param>
            <param name="ProjectExclusive">Open the project exclusive, noone else can open this project</param>
            <param name="ProjectCopy">Copy the project on the fileserver</param>
        </member>
        <member name="M:Eplan.EplApi.ApplicationFramework.IExtendedProcessor.GetExtendedOptions(Eplan.EplApi.Base.Context)">
            <summary>
Function for extended Options. Set the parameters in the context
</summary>
            <param name="oContext">Context with parameters</param>
            <returns> Returns true if successful.</returns>
        </member>
        <member name="M:Eplan.EplApi.ApplicationFramework.IExtendedProcessor.ExportDirect(System.String,Eplan.EplApi.Base.Context)">
            <summary>
Exports to a special file. All Parameter are in the context.
</summary>
            <param name="strOutputFile">Output file</param>
            <param name="oContext">Context with parameters</param>
            <returns> Returns true if successful.</returns>
        </member>
        <member name="M:Eplan.EplApi.ApplicationFramework.IExtendedProcessor.CanExportDirect(Eplan.EplApi.Base.Context,System.Boolean@)">
            <summary>
Indicates whether the converter provides an export.
</summary>
            <param name="oContext">Context with parameters</param>
            <param name="bSupportsProgress">Indicates whether the converter supports a progress bar.</param>
            <returns>true: export is possible; false: export is not possible</returns>
        </member>
        <member name="M:Eplan.EplApi.ApplicationFramework.IExtendedProcessor.ImportDirect(System.String,Eplan.EplApi.Base.Context)">
            <summary>
Imports the file to the system
EContext may point to an EProgress object to support a progress bar.
Returns true if successful.
</summary>
            <param name="strInputFile">Input file</param>
            <param name="oContext">Context with parameters</param>
        </member>
        <member name="M:Eplan.EplApi.ApplicationFramework.IExtendedProcessor.CanImportDirect(Eplan.EplApi.Base.Context,System.Boolean@)">
            <summary>
Indicates whether the converter can import external formats
</summary>
            <param name="oContext">Context with parameters</param>
            <param name="bSupportsProgress">Indicates whether the converter supports a progress bar.</param>
            <returns>true: conversion is possible; false: conversion is not possible</returns>
        </member>
        <member name="T:Eplan.EplApi.ApplicationFramework.IExtendedProcessor">
            <summary>
Interface for implementing an extended processor in connection  with the IXMLProcessor.
</summary>
            <seealso cref="!:XMLProcessor" />
        </member>
        <member name="M:Eplan.EplApi.ApplicationFramework.IXMLProcessor.PostExport">
            <summary>
Is called after export has been completed.
</summary>
            <returns>If true, an Information dialog box is displayed.</returns>
        </member>
        <member name="M:Eplan.EplApi.ApplicationFramework.IXMLProcessor.PostImport">
            <summary>
Is called after import has been completed.
</summary>
            <returns>If true, an Information dialog box is displayed.</returns>
        </member>
        <member name="M:Eplan.EplApi.ApplicationFramework.IXMLProcessor.GetOption">
            <summary>
Returns a settings dialog for this processor. 
Dialog is only created, but not displayed!
</summary>
            <returns>Interface of the created dialog.</returns>
        </member>
        <member name="M:Eplan.EplApi.ApplicationFramework.IXMLProcessor.GetErrorMessage">
            <summary>
Returns an error message if an error occured during export/import.
</summary>
            <returns>Error message</returns>
        </member>
        <member name="M:Eplan.EplApi.ApplicationFramework.IXMLProcessor.GetFileFilter">
            <summary>
Returns the filter string for the file selection box.
e.g. "Access *.mdb|*.mdb"
</summary>
            <returns>Filter string</returns>
        </member>
        <member name="M:Eplan.EplApi.ApplicationFramework.IXMLProcessor.Export(System.String,System.String,Eplan.EplApi.Base.Context)">
            <summary>
Converts the XML file to a special file.
</summary>
            <param name="strXmlFile">Input file</param>
            <param name="strOutputFile">Output file</param>
            <param name="oContext">Context with parameters</param>
            <returns> Returns true if successful.</returns>
        </member>
        <member name="M:Eplan.EplApi.ApplicationFramework.IXMLProcessor.CanExport(Eplan.EplApi.Base.Context,System.Boolean@)">
            <summary>
Indicates whether the converter provides an export option.
</summary>
            <param name="oContext">Context with parameters</param>
            <param name="bSupportsProgress">Indicates whether the converter supports a progress bar.</param>
            <returns>true: export is possible; false: export is not possible</returns>
        </member>
        <member name="M:Eplan.EplApi.ApplicationFramework.IXMLProcessor.Import(System.String,System.String,Eplan.EplApi.Base.Context)">
            <summary>
Conversion from sImportFile to sXmlFile.
sXmlFile might be passed as "". In this case, the converter must set a file name.
EContext may point to an EProgress object to support a progress bar.
Returns true if successful.
</summary>
            <param name="strInputFile">Input file</param>
            <param name="strXmlFile">Output file</param>
            <param name="oContext">Context with parameters</param>
        </member>
        <member name="M:Eplan.EplApi.ApplicationFramework.IXMLProcessor.CanImport(Eplan.EplApi.Base.Context,System.Boolean@)">
            <summary>
Indicates whether the converter can convert external formats to XML.
</summary>
            <param name="oContext">Context with parameters</param>
            <param name="bSupportsProgress">Indicates whether the converter supports a progress bar.</param>
            <returns>true: conversion is possible; false: conversion is not possible</returns>
        </member>
        <member name="M:Eplan.EplApi.ApplicationFramework.IXMLProcessor.GetName">
            <summary>
Returns the name of the converter.
</summary>
            <returns>Name of converter, is shown in selection list.</returns>
        </member>
        <member name="T:Eplan.EplApi.ApplicationFramework.IXMLProcessor">
            <summary>
Interface for implementing an XML processor.
</summary>
            <seealso cref="!:XMLProcessor" />
        </member>
        <member name="M:Eplan.EplApi.ApplicationFramework.IOptions.ShowOptions">
            <summary>
Is called if the settings dialog for an XML processor is to be displayed.

</summary>
        </member>
        <member name="T:Eplan.EplApi.ApplicationFramework.IOptions">
            <summary>
If a class implements this interface, a settings dialog can be assigned to the
XML processor.
</summary>
        </member>
        <member name="P:Eplan.EplApi.ApplicationFramework.IInterface.InterfaceName">
            <summary>
This name is used to register the type as an interface.
</summary>
        </member>
        <member name="T:Eplan.EplApi.ApplicationFramework.IInterface">
            <summary>
A type implementing this interface can be registered as an EPLAN interface.

</summary>
        </member>
        <member name="M:Eplan.EplApi.ApplicationFramework.IEplActionChecked.Checked(System.String,Eplan.EplApi.ApplicationFramework.ActionCallingContext)">
            <summary>
One action can have the state on off or mixed. Return 0 for off, 1 for on, and
2 for mixed.
</summary>
            <remarks>
This function is called often and should work fast.
</remarks>
            <param name="strActionName">The name of this action</param>
            <param name="actionContext">The calling context.</param>
            <returns>0: The return action has the state unchecked.
1: The return action has the state checked.
2: The return action has the state mixed.</returns>
        </member>
        <member name="T:Eplan.EplApi.ApplicationFramework.IEplActionChecked">
            <summary>
Interface to switch the status on / off of an Action. If this interface
is not used, the Action is off by default. If you
implement this interface in an action class, you can set the state of the
respective Action to on. 
If 0, unchecks; if 1, checks; and if 2, sets indeterminate.
</summary>
            <example>
                <code lang="c#">
public class TestAction : Eplan.EplApi.ApplicationFramework.IEplAction, Eplan.EplApi.ApplicationFramework.IEplActionChecked
    {
        //<i>IEplAction Members</i>

        \#region IEplActionChecked Members

        public int Checked(string strActionName, Eplan.EplApi.ApplicationFramework.ActionCallingContext actionContext)
        {
            if (strActionName == "TESTACTIONMIXED")
            {
                return 2;
            } 
			else if (strActionName == "TESTACTION")
            {
                return 1;
            }
            else 
            {
                return 0;
            }

        }

        \#endregion
    }
</code>
            </example>
        </member>
        <member name="M:Eplan.EplApi.ApplicationFramework.IEplActionEnable.Enabled(System.String,Eplan.EplApi.ApplicationFramework.ActionCallingContext)">
            <summary>
One action can be enabled or disabled. Return true when it is enabled.
</summary>
            <remarks>
This function is called often and should work performant.
</remarks>
            <param name="strActionName">The name of this action</param>
            <param name="actionContext">The callingcontext</param>
            <returns>true: The return action is enabled.</returns>
        </member>
        <member name="T:Eplan.EplApi.ApplicationFramework.IEplActionEnable">
            <summary>
Interface to enable or disable an Action. If this interface
is not used, the Action is enabled by default. If you
implement this interface in an action class, you can set the
respective Action to disabled. If a tool bar button or menu
item points to this Action, they will be also disabled
(greyed out).
</summary>
            <example>
                <code lang="c#">
public class TestAction : Eplan.EplApi.ApplicationFramework.IEplAction, Eplan.EplApi.ApplicationFramework.IEplActionEnable
    {
        //<i>IEplAction Members</i>

        \#region IEplActionEnable Members

        public bool Enabled(string strActionName, Eplan.EplApi.ApplicationFramework.ActionCallingContext actionContext)
        {
            if (strActionName == "TESTACTION")
            {
                return false;
            }
            else
            {
                return true;
            }

        }

        \#endregion
    }
</code>
            </example>
        </member>
        <member name="P:Eplan.EplApi.ApplicationFramework.Internal.IEplLicense.LicenseOption">
            <summary>
Gets a license option.
			
</summary>
            <returns>License option.</returns>
        </member>
        <member name="T:Eplan.EplApi.ApplicationFramework.Internal.IEplLicense">
            <summary>
Interface declaration for licensing. 
When an action, interface, verification or dialog must be licensed, this
interface must be implemented.
</summary>
            <example>Implementation of a licensed Action in an add-in, which needs Multiusermonitor license
<code lang="C#">
   public class NewAction: IEplAction, IEplLicense
   {	
       public bool Execute(ActionCallingContext ctx)
       {
           // TODO: 
           // Add code
           System.Windows.Forms.MessageBox.Show("NewAction was invoked!" );	

           return true;
       }

    public bool OnRegister(ref string Name, ref int Ordinal)
    {
        Name	= "NewAction";
        Ordinal	= 20;
        return true;
    }

    public  void GetActionProperties(ref ActionProperties actionProperties)
    {
        actionProperties.Description= "Description of NewAction";
    }

	public int LicenseOption
	{            
		get 
		{
			return (int)LicenseOptions.MultiuserMonitor;
		}
	}       
</code></example>
        </member>
        <member name="M:Eplan.EplApi.ApplicationFramework.IEplAddIn.OnExit">
            <summary>
Is called at system shutdown if the add-in was loaded at system startup!
</summary>
            <returns />
        </member>
        <member name="M:Eplan.EplApi.ApplicationFramework.IEplAddIn.OnInitGui">
            <summary>
Called by the framework if the user interface was initialized and the add-in can modify the user interface.
Is only called if the add-in is loaded at system startup!  <seealso cref="M:Eplan.EplApi.ApplicationFramework.IEplAddIn.OnRegister(System.Boolean@)" /></summary>
            <returns />
        </member>
        <member name="M:Eplan.EplApi.ApplicationFramework.IEplAddIn.OnInit">
            <summary>
Is called if the add-in is to be loaded at system start-up <seealso cref="M:Eplan.EplApi.ApplicationFramework.IEplAddIn.OnRegister(System.Boolean@)" />.
</summary>
            <returns />
        </member>
        <member name="M:Eplan.EplApi.ApplicationFramework.IEplAddIn.OnUnregister">
            <summary>
Is called once, when the add-in is removed from the system.
</summary>
            <returns />
        </member>
        <member name="M:Eplan.EplApi.ApplicationFramework.IEplAddIn.OnRegister(System.Boolean@)">
            <summary>
Is called once when a new add-in is selected.
</summary>
            <param name="bLoadOnStart">true: The module is loaded at system startup and OnInit() is called.</param>
            <returns>
 true, if the add-in was successfully loaded and registered.
</returns>
            <remarks>
When this function returns false, the add-in is not added to the system. At next start of EPLAN the 
add-in is not loaded.

If bLoadOnStart is set to false, the API add-in assembly is registered but not loaded automatically on the next startup of EPLAN. Still all actions registered with the add-in are known
in EPLAN and the addin will be loaded once one of the actions is executed. Please mind, that in this case OnInitGui(), etc. is only called, when the dll is loaded, so normal menu items
from the add-in are not created, when EPLAN starts.
</remarks>
        </member>
        <member name="T:Eplan.EplApi.ApplicationFramework.IEplAddIn">
            <summary>
Interface declaration for an EPLAN add-in.
If an assembly is to be loaded as an EPLAN add-in, exactly
one class of the assembly must implement this interface.
</summary>
        </member>
        <member name="F:Aflicense.m_bIsLicensingAvailable">
is licensing is available
</member>
        <member name="M:Aflicense.isLicensingAvailable">
Checks if licensing is available
</member>
        <member name="F:AfApplication.sm_Application">
************************************************************************
************************************************************************
</member>
        <member name="T:EUnicodeConverter">
EUnicodeConverter.h
</member>
        <member name="M:op_BitwiseAnd(IEArchive*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,EColor*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
global operator to write an EColor into an archive or to read it from
</member>
        <member name="M:EBox3D.getCenter">
get box center point 
</member>
        <member name="M:EBox3D.getDiagonal">
get box direction vector.
</member>
        <member name="M:EPosition3D.set(EPoint3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,EUnitVector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,EAngleType!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
conversion from eCabinet/Triga
</member>
        <member name="M:EPosition3D.set(EPoint3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,EUnitVector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,EUnitVector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
explicit set
</member>
        <member name="M:EPosition3D.#ctor(EPoint3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,EUnitVector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,EUnitVector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
conversion from eCabinet/Triga
</member>
        <member name="M:EPosition3D.#ctor(EPoint3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,EUnitVector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,EAngleType!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
explicit constructor
</member>
        <member name="M:EPosition3D.#ctor(ETransform3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
conversion from ETransform3D
</member>
        <member name="M:EPosition3D.#ctor(EPosition3D*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
copy constructor
</member>
        <member name="M:EPosition3D.#ctor(EPosition3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
copy constructor
</member>
        <member name="M:EPosition3D.#ctor">
default constructor
</member>
        <member name="F:EArc3D.m_Angle">
angle to End-Point
</member>
        <member name="F:EArc3D.m_StartVector">
Start-Point
</member>
        <member name="F:EArc3D.m_Normal">
normal vector 
</member>
        <member name="F:EArc3D.m_Origin">
center point
</member>
        <member name="M:EArc3D.set(EPoint3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,EUnitVector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,EVector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,EAngleType!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Methodes from Interface ICurve3D
	@see : ICurve3D

</member>
        <member name="M:EPath3D.getEndPoint">
Interface Function
</member>
        <member name="M:EPath3D.getStartPoint">
Interface Function
</member>
        <member name="M:EPath3D.isClosed">
Interface Function
</member>
        <member name="M:EContour3D.triangulate(std.vector&lt;ETriangle3D&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
triangulate closed contour
</member>
        <member name="M:EContour3D.getEndPoint">
Interface Function
</member>
        <member name="M:EContour3D.getStartPoint">
Interface Function
</member>
        <member name="M:EContour3D.isClosed">
Interface Function
</member>
        <member name="T:EPointArray3D">
represents an array of points

</member>
        <member name="M:EBoundingBox3D.checkBoxZRange(EBoundingBox3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
special Function to compare the Z-range of two bounding boxes. 
Needed for hidden line calculation.
returns a negative value if this Z-range is closer to 0 than bb
returns 0 if Z-ranges overlap
returns a positive value if bb Z-range is closer to 0 than this 

</member>
        <member name="M:EBoundingBox3D.isInsideBoxXY(EBoundingBox3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
special Function to compare two bounding boxes by ignoring z-axis. 
Needed for hidden line calculation.
True if this is inside or touching bb
False if this and bb are disjunct. 

</member>
        <member name="M:EBoundingBox3D.isInside(EPoint3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
special function for polygon inside/outside test:
		return value is true if point is inside, else
		LowCount is increased, if p is left, lower, nearer then LDF
		HighCount is increased, if p is right, upper, farer then RUB

</member>
        <member name="M:EBoundingBox3D.getSize">
returns getLength(GetDiagonale())
throw exception if (!isSet())
</member>
        <member name="M:EBoundingBox3D.getCenter">
returns getRub()-getLdf()/2
throw exception if (!isSet())
</member>
        <member name="M:EBoundingBox3D.getDiagonal">
returns getRub()-getLdf()
throw exception if (!isSet())
</member>
        <member name="M:EBoundingBox3D.getRub">
returns right, up back Point of the BoundingBox
throw exception if (!isSet())
</member>
        <member name="M:EBoundingBox3D.getRuf">
returns right, up, front Point of the BoundingBox
throw exception if (!isSet())
</member>
        <member name="M:EBoundingBox3D.getRdb">
returns right, down, back Point of the BoundingBox
throw exception if (!isSet())
</member>
        <member name="M:EBoundingBox3D.getRdf">
returns right, down, front Point of the BoundingBox
throw exception if (!isSet())
</member>
        <member name="M:EBoundingBox3D.getLub">
returns left, up, back Point of the BoundingBox
throw exception if (!isSet())
</member>
        <member name="M:EBoundingBox3D.getLuf">
returns left, up, front Point of the BoundingBox
throw exception if (!isSet())
</member>
        <member name="M:EBoundingBox3D.getLdb">
returns left, down, back Point of the BoundingBox
throw exception if (!isSet())
</member>
        <member name="M:EBoundingBox3D.getLdf">
returns left, down, front Point of the BoundingBox
throw exception if (!isSet())
</member>
        <member name="M:EBoundingBox3D.isSet">
check, if at least one point was set (is false after clear)
</member>
        <member name="M:EBoundingBox3D.merge(EBoundingBox3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
adds another BoundingBox
</member>
        <member name="M:EBoundingBox3D.merge(EPoint3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
adds one Point
</member>
        <member name="M:EBoundingBox3D.clear">
initializes the BoundingBox empty
</member>
        <member name="M:EBoundingBox3D.set(ERectangle!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double,System.Double)">
initializes the BoundingBox whith a 2D rectangle and the z range
</member>
        <member name="M:EBoundingBox3D.set(EPoint3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,EPoint3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
initializes the BoundingBox whith to corner points
</member>
        <member name="M:EBoundingBox3D.set(EPoint3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
initializes the BoundingBox as a cube with edges of "size" length
</member>
        <member name="M:EBoundingBox3D.set(EBoundingBox3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
initializes the BoundingBox by another BoundingBox
</member>
        <member name="M:EBoundingBox3D.set(EPoint3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
initializes the BoundingBox with one point (size()=0)
</member>
        <member name="M:EPlane3D.getDirectedDistance(EPoint3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
distance in direction of normal is positive, other side negative
this value will be negative(!) if the point is opposite to the nomal of the plane
</member>
        <member name="M:EPlane3D.intersect(EPlane3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,ERay3D*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
intersect Plane with plane; result is a ray 
</member>
        <member name="M:EPlane3D.intersect(ERay3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,EPoint3D*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
intersect ray with plane
</member>
        <member name="M:EPlane3D.project(EVector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
projected vector on plane
</member>
        <member name="M:EPlane3D.project(EPoint3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
projected point on plane
</member>
        <member name="M:EPlane3D.getPointFromPlane(EPoint!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Plane coordinates to world
</member>
        <member name="M:EPlane3D.getPointOnPlane(EPoint3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,EPoint*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
World coordinates to plane, true if exact on plane, else projected point
</member>
        <member name="M:EPlane3D.getDistance(EPoint3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
calculate minimal distance between Point and Plane
</member>
        <member name="M:EPlane3D.getDistanceSq(EPoint3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
calculate minimal distance between Point and Plane
</member>
        <member name="M:EPlane3D.transform(ETransform3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
transform plane
</member>
        <member name="M:EPlane3D.isOn(ERay3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
test if ray is flat in the plane
</member>
        <member name="M:EPlane3D.isOn(EVector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
test if vector is flat in the plane
</member>
        <member name="M:EPlane3D.isOn(EPoint3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
test if point is on Plane
</member>
        <member name="M:EPlane3D.isParallel(EPlane3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
check for parallel Planes, true if normals are colinear 
</member>
        <member name="M:EPlane3D.op_Equality(EPlane3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Plane equality operator.
</member>
        <member name="M:EPlane3D.getAxisV">
Plane V-Axis (calculated from normal)
</member>
        <member name="M:EPlane3D.getAxisU">
Plane U-Axis (calculated from normal)
</member>
        <member name="M:EPlane3D.getOrigin">
Plane getOrigin
</member>
        <member name="M:EPlane3D.getNormal">
Plane normal vector.
</member>
        <member name="M:ERay3D.rayDistance(EPoint3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
pkt is projected orthogonal to the ray. then the directed distance between the ray origin and this projection is calculated
	this is reverse to getPoint(dbl); 

pkt is projected orthogonal to the ray. then the directed distance between the ray origin and this projection is calculated
</member>
        <member name="M:ERay3D.rayDistanceSq(ERay3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
calculates distance between two rays
if result ==0.0, rays intersect, result has coordinates of the intersection point
if result &gt;0.0, the rays don't intersect, result has coordinates of the point of minimal distance on ray1.

</member>
        <member name="M:ERay3D.projectTo(EPoint3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
calculate closest point to given Point
</member>
        <member name="M:ERay3D.getDistance(EPoint3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
calculate minimal distance between Point and ray
</member>
        <member name="M:ERay3D.getDistanceSq(EPoint3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
calculate minimal distance between Point and Plane
</member>
        <member name="M:ERay3D.transform(ETransform3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
transform ray
</member>
        <member name="M:ERay3D.isOn(EPoint3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
ray is on 
</member>
        <member name="M:ERay3D.isParallel(ERay3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
check for parallel rays, true if directions are collinear 
</member>
        <member name="M:ERay3D.op_Equality(ERay3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
ray equality operator.
</member>
        <member name="M:ERay3D.getOrigin">
ray origin
</member>
        <member name="M:ERay3D.getDirection">
ray direction vector.
</member>
        <member name="M:ERay3D.setOrigin(EPoint3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
set ray getOrigin
</member>
        <member name="M:ERay3D.setDirection(EUnitVector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
set ray direction vector.
</member>
        <member name="M:ERay3D.#ctor(EPoint3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,EUnitVector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Constructor
</member>
        <member name="M:EUnitVector3D.normalizedScalarprod(EVector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
calculates scalarproduct with unit vectors
</member>
        <member name="M:EUnitVector3D.unit">
normalize to unit length
</member>
        <member name="M:EUnitVector3D.getLength">
get length
</member>
        <member name="M:EUnitVector3D.getLengthSq">
get square of length
</member>
        <member name="M:EUnitVector3D.op_SubtractionAssignment(EVector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
inplace subtract a vector
</member>
        <member name="M:EUnitVector3D.op_AdditionAssignment(EVector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
inplace add a vector
</member>
        <member name="M:EUnitVector3D.op_DivisionAssignment(System.Double!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
divide by a scale
</member>
        <member name="M:EUnitVector3D.op_MultiplicationAssignment(System.Double!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
multiplicate inplace by a scalar
</member>
        <member name="M:EUnitVector3D.set(System.Double!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
set ordinates
</member>
        <member name="M:EUnitVector3D.#ctor(EPoint3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
copy constructor
</member>
        <member name="M:EUnitVector3D.#ctor(EVector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
copy constructor
</member>
        <member name="M:EUnitVector3D.#ctor(System.Double!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
constructor
</member>
        <member name="M:EContour2D.addSegmentBegin(EPoint!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Alias of addSegmentPoint
</member>
        <member name="M:ETransform3D.getMov">
access to transformation vector component of the transformation
</member>
        <member name="M:ETransform3D.getMat">
access to rotation matrix component of the transformation
</member>
        <member name="M:ETransform3D.getScale">
calculates the scale of a 3D-transform. is the 3.root of getDeterminante
	does not work properly, if scaling for x y and z is different 
</member>
        <member name="M:ETransform3D.isMirror">
returns true, if the transformation does mirror objects
</member>
        <member name="M:ETransform3D.getDeterminante">
calculates the determinant of the matrix
</member>
        <member name="M:ETransform3D.transpose">
transpose Matrix (swap columns and rows)
</member>
        <member name="M:ETransform3D.op_UnaryNegation">
build inverse transform 
</member>
        <member name="M:ETransform3D.op_Multiply(System.Double!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
transform distance (eg. radius); does not work properly if scaling in x,y and z is different
</member>
        <member name="M:ETransform3D.transform(EVector3D*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
transform a vector inplace

transform a vector inplace
</member>
        <member name="M:ETransform3D.transform(EPoint3D*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
transform a pointvector inplace

transform a pointvector inplace
</member>
        <member name="M:ETransform3D.op_Multiply(EPoint3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
transform a pointvector
</member>
        <member name="M:ETransform3D.op_Multiply(EVector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
transform a vector
</member>
        <member name="M:ETransform3D.op_MultiplicationAssignment(ETransform3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
in place combine two transformation by matrix multiply
</member>
        <member name="M:ETransform3D.op_Multiply(ETransform3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
combine two transformation by matrix multiply
</member>
        <member name="M:ETransform3D.op_Equality(ETransform3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
test equality

test equality
</member>
        <member name="M:ETransform3D.setIdentity">
build identity transform
</member>
        <member name="M:ETransform3D.op_Assign(ETransform3D*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
move operator
</member>
        <member name="M:ETransform3D.op_Assign(ETransform3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
assignment operator
</member>
        <member name="M:ETransform3D.#ctor(EMatrix3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,EVector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
constructs a from values
</member>
        <member name="M:ETransform3D.#ctor(EVector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
constructs a translating ETransform3D
</member>
        <member name="M:ETransform3D.#ctor(EPoint3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,EVector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,EAngleType!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
constructs a rotation ETransform3D, that rotates counter clock wise around the given center point and axis
</member>
        <member name="M:ETransform3D.#ctor(EPoint3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,EVector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,EVector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
constructs a ETransform3D, from two axis and an origin point
</member>
        <member name="M:ETransform3D.#ctor(EVector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,EVector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
constructs a ETransform3D from two axis, calculates w = u%v
</member>
        <member name="M:ETransform3D.#ctor(EVector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,EVector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,EVector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
constructs a ETransform3D from three axis
</member>
        <member name="M:ETransform3D.#ctor(System.Double)">
constructs a scaling ETransform3D
</member>
        <member name="M:ETransform3D.#ctor(EAngleType!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,EAngleType!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,EAngleType!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
constructs a rotation ETransform3D by three angles 
</member>
        <member name="M:ETransform3D.#ctor(EAngleType!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,EVector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
constructs a rotation ETransform3D by axis and angle
</member>
        <member name="M:ETransform3D.#ctor(ETransform3D*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
the move constructor
</member>
        <member name="M:ETransform3D.#ctor(ETransform3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
the copy constructor
</member>
        <member name="M:ETransform3D.#ctor">
constructs a unit transform
</member>
        <member name="M:EMatrix3D.op_MultiplicationAssignment(EMatrix3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
in place combine two transformation by matrix multiply
</member>
        <member name="M:EMatrix3D.#ctor(System.Double!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.">
constructs a from values
</member>
        <member name="M:EMatrix3D.#ctor(System.Double!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
constructs a scaling matrix
</member>
        <member name="M:EMatrix3D.#ctor(EAngleType!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,EAngleType!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,EAngleType!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
constructs a rotation matrix by three angles 
</member>
        <member name="M:EMatrix3D.#ctor(EAngleType!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,EVector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
constructs a rotation matrix by axis and angle
</member>
        <member name="M:EMatrix3D.#ctor(EMatrix3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
the copy constructor

the move constructor
</member>
        <member name="M:EMatrix3D.#ctor">
constructs a unit matrix
</member>
        <member name="M:EVector3D.getV">
get as array of doubles 
</member>
        <member name="M:op_Multiply(System.Double!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,EVector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
friend operator, first operand not a W3dGeometry class 
skalar multiplication

skalar multiplication
</member>
        <member name="M:EVector3D.normalizedCrossprod(EVector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
calculates cross product with unit vectors
</member>
        <member name="M:EVector3D.normalizedScalarprod(EVector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
calculates scalarproduct with unit vectors
</member>
        <member name="M:EVector3D.getAngle(EVector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,EVector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
calculate angle between vectors (0-360), plane normal vector decides what is the right angle
</member>
        <member name="M:EVector3D.getAngleXY(EVector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
calculate angle between vectors (0-180)
</member>
        <member name="M:EVector3D.getAngle(EVector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
calculate angle between vectors (0-180)
</member>
        <member name="M:EVector3D.isNull">
faster test if getLength() equals 0.0
</member>
        <member name="M:EVector3D.isColinear(EVector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
test if two Vectors are colinear 
</member>
        <member name="M:EVector3D.unit">
normalize to unit length
</member>
        <member name="M:EVector3D.getLength">
get length
</member>
        <member name="M:EVector3D.getLengthSq">
get square of length
</member>
        <member name="M:EVector3D.op_Inequality(EVector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
test unequal; to bee implemented if needed 
</member>
        <member name="M:EVector3D.op_Equality(EVector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
test equal
</member>
        <member name="M:EVector3D.op_UnaryNegation">
negate a vector
</member>
        <member name="M:EVector3D.op_Modulus(EVector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
vector product
</member>
        <member name="M:EVector3D.op_Subtraction(EVector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
subtract a vector
</member>
        <member name="M:EVector3D.op_Addition(EVector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
add a vector
</member>
        <member name="M:EVector3D.op_Multiply(EVector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
scalar product
</member>
        <member name="M:EVector3D.op_Multiply(System.Double!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
multiplicate by a scalar
</member>
        <member name="M:EVector3D.op_SubtractionAssignment(EVector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
inplace subtract a vector
</member>
        <member name="M:EVector3D.op_AdditionAssignment(EVector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
inplace add a vector
</member>
        <member name="M:EVector3D.op_DivisionAssignment(System.Double!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
divide by a scale
</member>
        <member name="M:EVector3D.op_MultiplicationAssignment(System.Double!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
multiplicate inplace by a scalar
</member>
        <member name="M:EVector3D.set(System.Double!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
set ordinates
</member>
        <member name="M:EVector3D.getAt(System.UInt32)">
get cordinate at index (0, 1 or 2)

get coordinate 
</member>
        <member name="M:EVector3D.setZ(System.Double!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
set z coordinate

set z coordinate
</member>
        <member name="M:EVector3D.getZ">
get z coordinate

get z coordinate
</member>
        <member name="M:EVector3D.setY(System.Double!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
set y coordinate

set y coordinate
</member>
        <member name="M:EVector3D.getY">
get y coordinate

get y coordinate
</member>
        <member name="M:EVector3D.setX(System.Double!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
set x cordinate

set x cordinate
</member>
        <member name="M:EVector3D.getX">
get x cordinate

get x cordinate
</member>
        <member name="M:EVector3D.init">
clear content

clear content
</member>
        <member name="M:EVector3D.#ctor(EPoint3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
conversion constructor: treat point as vector
</member>
        <member name="M:EVector3D.#ctor(EPoint3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,EPoint3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
constructor
</member>
        <member name="M:EVector3D.#ctor(EVector3D*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
move constructor
</member>
        <member name="M:EVector3D.#ctor(EVector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
copy constructor
</member>
        <member name="M:EVector3D.#ctor(System.Double!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
constructor
</member>
        <member name="M:EVector3D.#ctor">
default constructor
</member>
        <member name="M:EPoint3D.getAt(System.UInt32)">
get coordinate 
</member>
        <member name="M:EPoint3D.getV">
get Point as array of doubles 

get as array of doubles 
</member>
        <member name="M:EPoint3D.distanceTo(EPoint3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
calculates distance 
</member>
        <member name="M:EPoint3D.distanceSqTo(EPoint3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
calculates square of distance (faster than calc distance)
</member>
        <member name="M:EPoint3D.setZ(System.Double!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
set z coordinate

set z coordinate
</member>
        <member name="M:EPoint3D.z">
get z coordinate

get z coordinate
</member>
        <member name="M:EPoint3D.setY(System.Double!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
set y coordinate

set y coordinate
</member>
        <member name="M:EPoint3D.y">
get y coordinate

get y coordinate
</member>
        <member name="M:EPoint3D.setX(System.Double!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
set x cordinate

set x cordinate
</member>
        <member name="M:EPoint3D.x">
get x cordinate

get x cordinate
</member>
        <member name="M:EPoint3D.#ctor(EVector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
conversion constructor
</member>
        <member name="M:EAngleType.op_UnaryNegation">
invert angle
</member>
        <member name="M:EAngleType.op_SubtractionAssignment(EAngleType!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
inplace add angles 
</member>
        <member name="M:EAngleType.op_Subtraction(EAngleType!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
add angles 
</member>
        <member name="M:EAngleType.op_AdditionAssignment(EAngleType!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
inplace add angles 
</member>
        <member name="M:EAngleType.op_Addition(EAngleType!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
add angles 
</member>
        <member name="M:EAngleType.value(enAngleType,System.Double!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
set Angle specifyed unit
</member>
        <member name="M:EAngleType.value(enAngleType)">
get Angle specifyed unit
</member>
        <member name="M:EAngleType.trn">
get Angle in turns; circle=1
</member>
        <member name="M:EAngleType.rad">
get Angle in radian; circle=2*PI
</member>
        <member name="M:EAngleType.deg">
get Angle in degrees; circle=360deg
</member>
        <member name="M:EAngleType.trn(System.Double!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
set Angle in turns; circle=1
</member>
        <member name="M:EAngleType.rad(System.Double!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
set Angle in radian; circle=2*PI
</member>
        <member name="M:EAngleType.deg(System.Double!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
set Angle in degrees; circle=360deg
</member>
        <member name="M:EAngleType.#ctor(EAngleType!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
copy constructor
</member>
        <member name="M:EAngleType.#ctor(enAngleType,System.Double!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
constructor
</member>
        <member name="M:EAngleType.#ctor">
default constructor
</member>
        <member name="T:enAngleType">
Type to define angle value range
</member>
        <member name="F:AT_TURNS">
circle 1.0
</member>
        <member name="F:AT_RADIAN">
circle 2*PI
</member>
        <member name="F:AT_DEGREE">
circle 360
</member>
        <member name="F:Eplan.EplApi.RemoteServer.RemotingCallingContext.m_strProjectName">
Daten
</member>
        <member name="M:Eplan.EplApi.RemoteServer.RemotingCallingContext.RemoveParameter(System.String)">
            <summary />
            <param name="strParameterName">Parameter name</param>
        </member>
        <member name="M:Eplan.EplApi.RemoteServer.RemotingCallingContext.ExistParameter(System.String)">
            <summary>
Check if the parameter <c>strParameterName</c> exists
</summary>
            <param name="strParameterName">Paramtername</param>
            <returns>True if <c>strParameterName</c> found.</returns>
        </member>
        <member name="M:Eplan.EplApi.RemoteServer.RemotingCallingContext.GetParameter(System.String,System.String@)">
            <summary />
            <param name="strParameterName">Paramter name</param>
            <param name="strParameterValue">Parameter value as return value</param>
            <returns>Parameter value if parameter exists otherwise nullptr</returns>
            <returns>Returns Parameter Value <c>strParameterValue</c>. If no Parameter found <c>strParameterValue</c> is set to nullptr</returns>
        </member>
        <member name="M:Eplan.EplApi.RemoteServer.RemotingCallingContext.AddParameter(System.String,System.String)">
            <summary />
            <param name="strParameterName">Parameter name</param>
            <param name="strNewParameterValue">Parameter value</param>
        </member>
        <member name="M:Eplan.EplApi.RemoteServer.RemotingCallingContext.Finalize">
            <summary> 
Non-deterministic Finalizer of RemotingCallingContext object.
</summary>
        </member>
        <member name="M:Eplan.EplApi.RemoteServer.RemotingCallingContext.Dispose">
            <summary> 
Destructor for deterministic finalization of RemotingCallingContext object.
</summary>
        </member>
        <member name="T:Eplan.EplApi.RemoteServer.RemotingCallingContext">
For internal use only.
This is the RemotingCallingContext class used to pass data used for remote calls.						
</member>
        <member name="M:Eplan.EplApi.ApplicationFramework.Internal.SystemServices.LoadAssembly(System.String)">
            <summary>
For internal use only.
Used to load Assemblies if a license and/or signature check is required.
If so, then the assembly must not be loaded directly for ex. with LoadFrom,
use this method instead. 
</summary>
            <param name="strAssemblyPath">
For internal use only. 
</param>
            <returns>
For internal use only. 
</returns>
        </member>
        <member name="T:Eplan.EplApi.ApplicationFramework.Internal.SystemServices">
            <exclude>
For internal use only. 
</exclude>
        </member>
        <member name="M:Eplan.EplApi.ApplicationFramework.IEplAction.GetActionProperties(Eplan.EplApi.ApplicationFramework.ActionProperties@)">
            <summary>
Returns descriptive data for the action. For documentation purposes only.
</summary>
            <param name="actionProperties">
The data structure <see text="Eplan.EplApi.ApplicationFramework.ActionProperties" cref="T:Eplan.EplApi.ApplicationFramework.ActionProperties" /> is filled with the properties. 
</param>
        </member>
        <member name="M:Eplan.EplApi.ApplicationFramework.IEplAction.Execute(Eplan.EplApi.ApplicationFramework.ActionCallingContext)">
            <summary>
Called by the framework when the action is to be performed.
</summary>
            <returns> true, if the action was successfully performed; </returns>
            <param name="oActionCallingContext">
Parameter for this call, see <see text="Eplan.EplApi.ApplicationFramework.ActionCallingContext" cref="T:Eplan.EplApi.ApplicationFramework.ActionCallingContext" />.
</param>
            <returns>
true, if the action was successfully registered in the system.
</returns>
        </member>
        <member name="M:Eplan.EplApi.ApplicationFramework.IEplAction.OnRegister(System.String@,System.Int32@)">
            <summary>
The action can be registered under a name determined by the
action and an overload level.
</summary>
            <param name="Name">Name under which the action is
                   registered in the system. Note\:
                   Action names with . are not allowed.</param>
            <param name="Ordinal">Overload level of action</param>
            <returns>
true: the return parameters are valid.
</returns>
            <returns> false: the action is registered under the name of the class that implements this interface; </returns>
        </member>
        <member name="T:Eplan.EplApi.ApplicationFramework.IEplAction">
            <summary>
Interface declaration for an action. 
When an action is to be registered for an add-in (an assembly) in the system, this
interface must be implemented by a class of the add-in.
</summary>
            <remarks> 
Action names with . are not allowed.
</remarks>
            <example>Implementation of a Action in an add-in
<code lang="C#">
   public class NewAction: IEplAction
   {	
       public bool Execute(ActionCallingContext ctx)
       {
           // TODO: 
           // Add code
           System.Windows.Forms.MessageBox.Show("NewAction was invoked!" );	

           return true;
       }

    public bool OnRegister(ref string Name, ref int Ordinal)
    {
        Name	= "NewAction";
        Ordinal	= 20;
        return true;
    }

    public  void GetActionProperties(ref ActionProperties actionProperties)
    {
        actionProperties.Description= "Description of NewAction";
    }
</code></example>
        </member>
        <member name="T:Eplan.EplApi.ApplicationFramework.EnableCondition">
            <summary>
To enable or disable a menu item via API you can use the internal menu conditions. 
Menu conditions are not so detailed as an own <see text="Enabled()-function" cref="!:Eplan::EplApi::ApplicationFramework::IEplActionEnable::Enabled" />
of the action but of high performance. You should use the internal menu conditions where ever it is possible.
</summary>
            <remarks>
The menu condition is a string. The condition has to be signed as an attribute above the action implementation.
Inside the string you can combine several menu conditions with the 'or'(||) or 'and' of C++, but it is not allowed to mix 
'or' and 'and' up to now. In addition you can negotiate a menu condition with !.
</remarks>
            <remarks>
you can get a list of all implemented menu conditions, if you search in all *.h files of our internal source code
for the interface "IMfEnableDisableMenue"; you will find the most of them in layer "GedFramework"
</remarks>
            <param name="strCondition">
the string which contains the menu condition or a combination of them
</param>
            <example>
example for a combination
<code>
[EnableCondition("XGedSingleSelectionCondition || XGedFunction3dSelectedCondition")]
class UpdateTerminalFuncDefAction : IEplAction
{
}
</code>
example for a negotiation
<code>
[EnableCondition("!XGedIsGedOpenCondition")]
public class StartEDPConfiguratorOnSelectionAction : IEplAction
{
}
</code></example>
        </member>
        <member name="M:Eplan.EplApi.ApplicationFramework.ActionManager.FindBaseActionFromFunctionAction(System.Boolean)">
            <summary>
This function searches the base action for an existing action in scripting.
the base action has the same name, but a lower ordinal.
</summary>
            <param name="bSilent">
true: no error is reported in the system errors when the action is not found.
</param>
            <returns>
Returns a reference to a <see text="Eplan.EplApi.ApplicationFramework.Action" cref="T:Eplan.EplApi.ApplicationFramework.Action" />
or NULL in case no action with this name exists in the system.
</returns>
        </member>
        <member name="M:Eplan.EplApi.ApplicationFramework.ActionManager.FindBaseAction(Eplan.EplApi.ApplicationFramework.IEplAction,System.Boolean)">
            <summary>
This function searches the base action for an existing action
the base action has the same name, but a lower ordinal.
</summary>
            <param name="pAction">
the action you search the base action. 
</param>
            <param name="bSilent">
true: no error is reported in the system errors when the action is not found.
</param>
            <returns>
Returns a reference to a <see text="Eplan.EplApi.ApplicationFramework.Action" cref="T:Eplan.EplApi.ApplicationFramework.Action" />
or NULL in case no action with this name exists in the system.
</returns>
        </member>
        <member name="M:Eplan.EplApi.ApplicationFramework.ActionManager.FindAction(System.String,System.Boolean)">
            <summary>
This function searches for an action registered in the system.
</summary>
            <param name="strNameOfAction">
Name of the action you search for. 
</param>
            <param name="bSilent">
true: no error is reported in the system errors when the action is not found.
</param>
            <returns>
Returns a reference to a <see text="Eplan.EplApi.ApplicationFramework.Action" cref="T:Eplan.EplApi.ApplicationFramework.Action" />
or NULL in case no action with this name exists in the system.
</returns>
        </member>
        <member name="M:Eplan.EplApi.ApplicationFramework.ActionManager.FindAction(System.String)">
            <summary>
This function searches for an action registered in the system.
</summary>
            <param name="strNameOfAction">
Name of the action you search for. 
</param>
            <returns>
Returns a reference to a <see text="Eplan.EplApi.ApplicationFramework.Action" cref="T:Eplan.EplApi.ApplicationFramework.Action" />
or NULL in case no action with this name exists in the system.
</returns>
        </member>
        <member name="T:Eplan.EplApi.ApplicationFramework.ActionManager">
            <summary>
Class for retrieving Action objects
</summary>
            <example>
\ \ 
<code lang="c#">
[C#]
ActionManager oColl = ActionManager();
Action oAction = oColl.FindAction("DemoAction");
if (oAction != null)
{
    System.String strDescription = oAction.ActionProperties.Description;
}
</code><code lang="c#">
[Visual Basic]
</code><code>
Dim oColl As ActionManager()
Dim oAction As Action = oColl.FindAction("DemoAction")
If Not (oAction Is Nothing) Then
    Dim strDescription As System.String = oAction.ActionProperties.Description
End If
</code></example>
        </member>
        <member name="M:Eplan.EplApi.Scripting.DeclareUnregister.#ctor">
            <summary>
Creates a new attribute. 
</summary>
        </member>
        <member name="T:Eplan.EplApi.Scripting.DeclareUnregister">
            <summary>
When a new script is unloaded from P8, this function is
called before removing it.
</summary>
\ \                                                    
</member>
        <member name="M:Eplan.EplApi.Scripting.DeclareRegister.#ctor">
            <summary>
Creates a new attribute. 
</summary>
        </member>
        <member name="T:Eplan.EplApi.Scripting.DeclareRegister">
            <summary>
When a new script is loaded in P8, this function is called.
</summary>
\ \                                                        
</member>
        <member name="M:Eplan.EplApi.Scripting.DeclareEventHandler.#ctor(System.String)">
            <summary>
This function of the script is registered as an event handler in the system.
</summary>
            <param name="strEventName">                                                 
The event handler responds to this event.
</param>
        </member>
        <member name="T:Eplan.EplApi.Scripting.DeclareEventHandler">
            <summary>
When a script function is to respond to events in the system,
the function has to be marked with this attribute.


</summary>
            <seealso cref="!:Script_EventHandling" />
        </member>
        <member name="P:Eplan.EplApi.Scripting.DeclareAction.Ordinal">
            <summary>
Overload level of the action. 
</summary>
            <returns>
Returns the overload level of the action.
</returns>
        </member>
        <member name="P:Eplan.EplApi.Scripting.DeclareAction.Name">
            <summary>
Name of the action. 
</summary>
            <returns>
Returns the name of the action.
</returns>
        </member>
        <member name="M:Eplan.EplApi.Scripting.DeclareAction.#ctor(System.String,System.Int32)">
            <summary>
Used to mark a function of a class in a script
if the function of this script is to be registered as an action in the system.
</summary>
            <param name="strActionName">
The function is saved with this name as an action in the system.
</param>
            <param name="iOrdinal">
This overload level is used when registering the action in the system.
</param>
        </member>
        <member name="M:Eplan.EplApi.Scripting.DeclareAction.#ctor(System.String)">
            <summary>
Used to mark a function of a class in a script
if the function of this script is to be registered as an <see text="Eplan.EplApi.ApplicationFramework.Action" cref="T:Eplan.EplApi.ApplicationFramework.Action" /> in the system.
</summary>
            <param name="strActionName">
The function is saved with this name as an <see text="Eplan.EplApi.ApplicationFramework.Action" cref="T:Eplan.EplApi.ApplicationFramework.Action" /> in the system.
</param>
        </member>
        <member name="T:Eplan.EplApi.Scripting.DeclareAction">
            <summary>
Attribute used to mark a method of a class in a <see text="script" cref="!:Scripts" />
so that this method will be registered as an <see text="Eplan.EplApi.ApplicationFramework.Action" cref="T:Eplan.EplApi.ApplicationFramework.Action" />
in the system. If a method, which is marked by the
DeclareAction attribute has string parameters, these
\parameters will be recognized as parameters of the Action.
</summary>
            <seealso cref="T:Eplan.EplApi.ApplicationFramework.Action" />
        </member>
        <member name="T:Eplan.EplApi.Scripting.Start">
            <summary>
Used to mark a function of a class in a <see text="script" cref="!:Scripts" />.
Once the script is run, this function is called. This
function may also have <see text="parameters" cref="!:SimpleScriptWithParameters" />.
</summary>
        </member>
        <member name="P:Eplan.EplApi.ApplicationFramework.Action.ActionProperties">
            <summary>
Descriptive data for this action.
</summary>
        </member>
        <member name="P:Eplan.EplApi.ApplicationFramework.Action.ModuleName">
            <summary>
Name of the module in which this action is implemented. 
</summary>
        </member>
        <member name="P:Eplan.EplApi.ApplicationFramework.Action.Name">
            <summary>
Name used to identify this action in the system. 
</summary>
        </member>
        <member name="M:Eplan.EplApi.ApplicationFramework.Action.Execute(Eplan.EplApi.ApplicationFramework.ActionCallingContext)">
            <summary>Performs the actual action.</summary>
            <param name="oCallingContext">
Using this parameter generic parameters of variable number and different 
types can be passed to the action.
</param>
            <returns>
true: This function was completed successfully. 
false: An error occurred while performing the action.
</returns>
            <remarks> Exceptions, which occur during the execution of an action 
can be retrieved from the ActionCallingContext by the GetException() method.
</remarks>
            <exception cref="T:Eplan.EplApi.Base.BaseException">
Exceptions may occur while performing the action.
All these exceptions are returned as BaseException.
</exception>
        </member>
        <member name="M:Eplan.EplApi.ApplicationFramework.Action.#ctor(AfAction*)">
            <summary>
For internal use only. 
</summary>
            <param name="pAction">
For internal use only.
</param>
        </member>
        <member name="T:Eplan.EplApi.ApplicationFramework.Action">
            <summary>
An action performs a task in the system. It is usually called
via menu items or the <see text="command line" cref="!:CommadLineCall" />.
\Parameters can be passed to the action in a context class,
and return values can be obtained with this parameter.
Actions are implemented in an add-in by deriving a class from
<see text="Eplan.EplApi.ApplicationFramework.IEplAction" cref="!:Eplan::EplApi::ApplicationFramework::IEplAction" />.
</summary>
            <remarks>
Actions are registered under a name <see text="Eplan.EplApi.ApplicationFramework.Action.Name" cref="P:Eplan.EplApi.ApplicationFramework.Action.Name" />
in the system. Using this name, you can find an action and
call its execution function <see text="Eplan.EplApi.ApplicationFramework.Action.Execute" cref="!:Eplan::EplApi::ApplicationFramework::Action::Execute@ActionCallingContext ^" />.

Please mind, that Microsoft.Net framework 3.5 contains a
class System.Action. If you include the namespace
Eplan.EplApi.ApplicationFramework in your code file by e.g. a
using statement without the use of an alias, you might get a
compiler error like: "'Action' is an ambiguous reference
between 'System.Action' and
'Eplan.EplApi.ApplicationFramework.Action'". 
Action names with . are not allowed.
</remarks>
        </member>
        <member name="M:Eplan.EplApi.ApplicationFramework.AfLockingSetHandleVector.ResumeManualLock(System.Int32!System.Runtime.CompilerServices.IsLong)">
            <summary>
Internal method, sets AutoLockActive flag to value used before PauseManualLock if LockingSet has been created.
</summary>
        </member>
        <member name="M:Eplan.EplApi.ApplicationFramework.AfLockingSetHandleVector.PauseManualLock">
            <summary>
Internal method, sets AutoLockActive flag to its original value (before first locking step)
</summary>
        </member>
        <member name="M:Eplan.EplApi.ApplicationFramework.AfLockingSetHandleVector.EndLockingStep(System.Int32!System.Runtime.CompilerServices.IsLong)">
            <summary>
Ends a locking step identified by nLockingStepId. ManualLocking mode is set to its previous value; Original locking state is restored.
Use LockingStep object to create and dispose locking steps.
</summary>
            <param name="nLockingStepId">
LockingStep identifier.
</param>
        </member>
        <member name="M:Eplan.EplApi.ApplicationFramework.AfLockingSetHandleVector.StartLockingStep">
            <summary>
Starts a locking step. ManualLocking mode is set to ON; Gets the position in LockingVector (in order to restore locking state when LockingStep is disposed).
Use LockingStep object to create and dispose locking steps.
</summary>
            <returns>
Locking step identifier.
</returns>
        </member>
        <member name="M:Eplan.EplApi.ApplicationFramework.AfLockingSetHandleVector.SetInternal(Eplan.EplApi.ApplicationFramework.ILockingVector)">
            <summary>
Sets the internal LockingVector. Used by Eplan.EplApi.DataModule to initalize LockingVector object.
</summary>
        </member>
        <member name="F:Eplan.EplApi.ApplicationFramework.AfLockingSetHandleVector.m_pInternal">
            <summary>
Vector of handles which is resized -up when locking, -down when going back to bookmark.
</summary>
        </member>
        <member name="F:Eplan.EplApi.ApplicationFramework.AfLockingSetHandleVector.s_pInstance">
            <summary>
Static member: singelton instance
</summary>
        </member>
        <member name="T:Eplan.EplApi.ApplicationFramework.AfLockingSetHandleVector">
            <summary>
Used by LockingVector object internally
</summary>
        </member>
        <member name="M:Eplan.EplApi.ApplicationFramework.LockingVectorProxy.ResumeManualLock(System.Int32!System.Runtime.CompilerServices.IsLong)">
            <summary>
Internal method, sets internal AutoLockActive flag to value before PauseManualLock.
Used for calling internal actions and methods which are not handlig manual locking.
</summary>
        </member>
        <member name="M:Eplan.EplApi.ApplicationFramework.LockingVectorProxy.PauseManualLock">
            <summary>
Internal method, sets internal AutoLockActive flag to its original value (value before first locking step).
Used for calling internal actions and methods which are not handlig manual locking.
</summary>
        </member>
        <member name="M:Eplan.EplApi.ApplicationFramework.LockingVectorProxy.EndLockingStep(System.Int32!System.Runtime.CompilerServices.IsLong)">
            <summary>
Ends locking step. Use <see text="Eplan.EplApi.DataModel.LockingStep" cref="!:Eplan::EplApi::DataModel::LockingStep" /> instead.
</summary>
            <param name="nLockingStepId"> Id of last step to unlock. </param>
        </member>
        <member name="M:Eplan.EplApi.ApplicationFramework.LockingVectorProxy.StartLockingStep">
            <summary>
Starts locking step. Use <see text="Eplan.EplApi.DataModel.LockingStep" cref="!:Eplan::EplApi::DataModel::LockingStep" /> instead.
</summary>
        </member>
        <member name="M:Eplan.EplApi.ApplicationFramework.LockingVectorProxy.SetInternal(Eplan.EplApi.ApplicationFramework.ILockingVector)">
            <summary>
Sets internal lockingvector object. Used internally, automatcally.
</summary>
        </member>
        <member name="M:Eplan.EplApi.ApplicationFramework.LockingVectorProxy.Finalize">
            <summary> 
Non-deterministic Finalizer of LockingVectorProxy object.
</summary>
        </member>
        <member name="M:Eplan.EplApi.ApplicationFramework.LockingVectorProxy.Dispose">
            <summary> 
Destructor for deterministic finalization of LockingVectorProxy object.				
</summary>
        </member>
        <member name="T:Eplan.EplApi.ApplicationFramework.LockingVectorProxy">
            <summary>
This class manages locking, but is is not needed to call it directly.
Use <see text="Eplan.EplApi.DataModel.LockingStep" cref="!:Eplan::EplApi::DataModel::LockingStep" /> or 
<see text="Eplan.EplApi.DataModel.LockingVector" cref="!:Eplan::EplApi::DataModel::LockingVector" />class instead.
</summary>
            <seealso cref="!:Eplan::EplApi::DataModel::LockingStep" />
            <seealso cref="!:Eplan::EplApi::DataModel::LockingVector" />
        </member>
        <member name="T:Eplan.EplApi.ApplicationFramework.ILockingVector">
            <summary>
Interface declaration for LockingVector member.
Used to implement LockingVector in DataModel and pass object back to Eplan.EplApi.AF
</summary>
        </member>
        <member name="M:Eplan.EplApi.ApplicationFramework.CommandLineInterpreter.Execute(System.String)">
            <summary>
Execution of a command.
</summary>
            <param name="strExpression">
Action plus arguments
</param>
            <returns>
true: The command line operation was successfully completed.
false: One or more errors occured while executing the command line operation.
</returns>
        </member>
        <member name="M:Eplan.EplApi.ApplicationFramework.CommandLineInterpreter.Execute(System.String,Eplan.EplApi.ApplicationFramework.ActionCallingContext)">
            <summary>
Execution of a command line expression.
</summary>
            <param name="strExpression">
Action plus arguments
</param>
            <param name="oContext">
The context assigned to the action. Additional data can be encapsulated
by the user here.
</param>
            <returns>
true: The command line operation was successfully completed.
false: One or more errors occured while executing the command line operation.
</returns>
        </member>
        <member name="M:Eplan.EplApi.ApplicationFramework.CommandLineInterpreter.IsExecutable(System.String)">
            <summary>
Checks whether the execution of an expression is possible.
This is only the case when the corresponding action is available.
</summary>
            <param name="strExpression">
Command line expression to be checked.
</param>
            <returns>
true, if command line expression is valid
false, if command line expression cannot be executed.
</returns>
        </member>
        <member name="M:Eplan.EplApi.ApplicationFramework.CommandLineInterpreter.#ctor(System.Boolean)">
            <summary>
constructor
</summary>
            <param name="bEnableExceptions">
If true then, if an exception raised, it will be transmitted to the caller.
If false, only a boolean value will be returned by calling Execute method. If this returned value is false, this means
the action has not succeed. Otherwise all things are OK. 
</param>
            <remarks>
The type of exceptions which can be raised, if parameter bEnableExceptions=true, is from System::BaseException.
</remarks>
        </member>
        <member name="M:Eplan.EplApi.ApplicationFramework.CommandLineInterpreter.#ctor">
            <summary>
constructor
</summary>
            <remarks>
If an exception raised while executing the action, it will not be transmitted to the caller.
</remarks>
        </member>
        <member name="T:Eplan.EplApi.ApplicationFramework.CommandLineInterpreter">
            <summary>
Class for executing commands in command-line style.
</summary>
            <example>Example of executing command-line commands
<code lang="C#">
String strAction= @"XPrjActionProjectOpen /PROJECT:";

bool bRet= CommandLineInterpreter().Execute(strAction + ProjectName);
if (!bRet)
{
   MessageBox.Show("P8 command does not work", "OpenProjectAndPage");
   CommandLineInterpreter.Execute("SystemErrDialog");
   return -1;
}
</code></example>
        </member>
        <member name="M:Eplan.EplApi.ApplicationFramework.ICommandLineInterpreter.Execute(System.String)">
            <summary>
For internal use only.  
</summary>
            <param name="strExpression">
For internal use only. 
</param>
            <returns>
For internal use only. 
</returns>
        </member>
        <member name="M:Eplan.EplApi.ApplicationFramework.ICommandLineInterpreter.Execute(System.String,Eplan.EplApi.ApplicationFramework.ActionCallingContext)">
            <summary>
For internal use only.  
</summary>
            <param name="strExpression">
For internal use only. 
</param>
            <param name="oContext">
For internal use only. 
</param>
            <returns>
For internal use only. 
</returns>
        </member>
        <member name="M:Eplan.EplApi.ApplicationFramework.ICommandLineInterpreter.IsExecutable(System.String)">
            <summary>
For internal use only.  
</summary>
            <param name="strExpression">
For internal use only. 
</param>
            <returns>
For internal use only. 
</returns>
        </member>
        <member name="T:Eplan.EplApi.ApplicationFramework.ICommandLineInterpreter">
            <summary>
For internal use only. A fixed interface ID is specified
which is used to generate this interface in W3u.exe. This ID
is specified in the source code and cannot be changed. 
</summary>
        </member>
        <member name="M:Eplan.EplApi.ApplicationFramework.ActionCallingContext.GetException">
            <summary>
Get Exception				
</summary>
        </member>
        <member name="M:Eplan.EplApi.ApplicationFramework.ActionCallingContext.SetContextParameter(Eplan.EplApi.Base.ContextParameterBlock)">
            <summary>
Set the block with parameters. This is a possibility to add objects to a
context.
</summary>
            <param name="pParams">The new block to set at this context</param>
        </member>
        <member name="M:Eplan.EplApi.ApplicationFramework.ActionCallingContext.GetContextParameter">
            <summary>
Get the block with parameters. This is a possibility to add objects to a
context.
</summary>
            <returns>
The Block
</returns>
        </member>
        <member name="M:Eplan.EplApi.ApplicationFramework.ActionCallingContext.GetAfActionCallingContext">
            <summary>
For internal use only.
</summary>
            <returns>
For internal use only.
</returns>
        </member>
        <member name="M:Eplan.EplApi.ApplicationFramework.ActionCallingContext.SetToolTipString(System.String)">
            <summary>
Sets the tooltip string of the associated menu item or toolbar button.
</summary>
            <param name="strToolTip">Tooltip string</param>
        </member>
        <member name="M:Eplan.EplApi.ApplicationFramework.ActionCallingContext.SetAfActionCallingContext(AfActionCallingContext*)">
            <summary>
For internal use only.
</summary>
        </member>
        <member name="M:Eplan.EplApi.ApplicationFramework.ActionCallingContext.Finalize">
            <summary>
Non-deterministic Finalizer of ActionCallingContext object.
</summary>
        </member>
        <member name="M:Eplan.EplApi.ApplicationFramework.ActionCallingContext.Dispose">
            <summary>
Destructor for deterministic finalization of ActionCallingContext object.
</summary>
        </member>
        <member name="M:Eplan.EplApi.ApplicationFramework.ActionCallingContext.#ctor">
            <summary>
Creates an ActionCallingContext
</summary>
        </member>
        <member name="M:Eplan.EplApi.ApplicationFramework.ActionCallingContext.#ctor(AfActionCallingContext*,System.Boolean)">
            <summary>
For internal use only. 
</summary>
            <param name="pAfActionCallingContext">
For internal use only. 
</param>
        </member>
        <member name="M:Eplan.EplApi.ApplicationFramework.ActionCallingContext.#ctor(AfActionCallingContext*)">
            <summary>
For internal use only. 
</summary>
            <param name="pAfActionCallingContext">
For internal use only. 
</param>
        </member>
        <member name="T:Eplan.EplApi.ApplicationFramework.ActionCallingContext">
            <summary>
This is the ActionCallingContext class used to pass
\parameters to an action and to receive return values of the
action.
</summary>
            <remarks>
Using AddParameter(...) you can add explicitly named
\parameters to ActionCallingContext. The action must use this
explicit name to reference these parameters. Likewise, values
returned by the action can be added.



Please mind, that an Action may modify the
ActionCallingContext dureing its execution. Sometimes e.g.
project Ids are added to the context and are passed to an
inner action. Re-using the same ActionCallingContext for a
further Action call may lead to unexpected results. So in
most cases, it is advisable to create a new
ActionCallingContext for a new Action call. 
</remarks>
        </member>
        <member name="M:Eplan.EplApi.ApplicationFramework.IActionCallingContext.SetToolTipString(System.String)">
            <summary>
Sets the tooltip string of the associated menu item or toolbar button.
</summary>
            <param name="strToolTip">
Tooltip string
</param>
        </member>
        <member name="T:Eplan.EplApi.ApplicationFramework.IActionCallingContext">
            <summary>
Interface class for the <see text="Eplan.EplApi.ApplicationFramework.ActionCallingContext" cref="!:Eplan::EplApi::ApplicationFramework::ActionCallingContext" /> class.
Can be used instead of the class in function parameters.
</summary>
        </member>
        <member name="M:Eplan.EplApi.ApplicationFramework.UserRights.GetCategories">
            <summary>
\returns the full names of all existing user rights
categories.
</summary>
            <returns>
the full category names in a string collection. The names are
needed in order to add a new right to an existing category.
</returns>
        </member>
        <member name="M:Eplan.EplApi.ApplicationFramework.UserRights.DeleteRight(System.String)">
            <summary>
Deletes the specified right entry from the UserRights
database (rights management dialog)
</summary>
            <param name="strRightname">name of the user right entry to
                           remove</param>
            <returns>
true, in case the right was successfully removed from the
rights management database.
</returns>
            <remarks>
The currently logged-in user must have the
URShowAdministrationDialog right, this is the right to work
on user rights. Any group assignments of this right are
removed. 
</remarks>
        </member>
        <member name="M:Eplan.EplApi.ApplicationFramework.UserRights.AddRight(System.String,System.String)">
            <summary>
Adds the specified right entry to the given category of the
custom UserRights file. The new right name will appear in the
rights management dialog.
</summary>
            <param name="strRightname">right name string </param>
            <param name="strCategory">category name string. Only
                          existing categories can be used.
                          You can get the existing
                          categories by the GetCategories
                          method. You need to set the
                          complete category name, you find
                          in the StringCollection returned
                          by GetCategory.</param>
            <returns>
true, in case the new right was successfully added to the
rights management database.
</returns>
            <remarks>
The currently logged-in user must have the
URShowAdministrationDialog right, this is the right to work
on user rights. 
The custom user rights will be saved to the file
"$(EPLAN_DATA)\\Administration\\customrights.erm". The system administrator needs to protect this file from changes by unauthorized persons.
</remarks>
            <exception cref="!:System.ApplicationException">Thrown when logged-in user has not enough right to work on user rights.</exception>
            <exception cref="!:System.ArgumentException">Thrown when given right <c>strRightname</c> already exist.</exception>
            <exception cref="!:System.ArgumentException">Thrown when category <c>strCategory</c> does not exist.</exception>
        </member>
        <member name="M:Eplan.EplApi.ApplicationFramework.UserRights.GetGroups(System.String)">
            <summary>
Gets the groups from user rights management, to which the
specified user belongs..
</summary>
            <returns>
The groups, the user belongs to.
</returns>
            <param name="strUser">Name of user. </param>
        </member>
        <member name="M:Eplan.EplApi.ApplicationFramework.UserRights.SetUser(System.String,System.String)">
            <summary>
Sets the user.
</summary>
            <returns> 
True: User was changed.
False: User was not changed.
</returns>
        </member>
        <member name="M:Eplan.EplApi.ApplicationFramework.UserRights.GetUser">
            <summary>
Gets the user.
</summary>
            <returns> 
The user.
</returns>
        </member>
        <member name="M:Eplan.EplApi.ApplicationFramework.UserRights.CheckRightFor(System.String)">
            <summary>
Checks the execute permission of an action
</summary>
            <param name="strRight">Name of the execute permission to be
                       checked. </param>
            <returns>
true: Action is granted execute permission. false: The action
must not be executed by the current user.
</returns>
            <example>
\Example of querying a right
<code lang="C#">

UserRights oUserRights = <b>new</b> UserRights();
<b>bool</b> bRights = oUserRights.CheckUserRights(); // is the user rights management activated?
<b>if</b> (bRights)
{

  <b>bool</b> bAnRight= oUserRights.CheckRightFor("XPLEditorStart");
}
</code></example>
            <remarks>
Before executing newly programmed functions, the API
programmer should check a right that is relatively similar to
that of the new function. If, for example, a function is
implemented that generates new pages, the right to create
pages (XGedNewSchemePage) should be queried beforehand.



If you check for a right, which is not yet added to the
UserRights database, this right is always granted.
</remarks>
        </member>
        <member name="M:Eplan.EplApi.ApplicationFramework.UserRights.CheckUserRights">
            <summary>
Queries, whether the rights management is currently active.
</summary>
            <returns>
true: Rights management activated in the system; false: No
rights management activated in the system.
</returns>
            <remarks>
This method does not change the current mode of rights
management. It only checks, whether the rights management is
active or not.
</remarks>
        </member>
        <member name="T:Eplan.EplApi.ApplicationFramework.UserRights">
            <summary>
Class for checking execute permissions. In the rights
management module, you can assign execute permissions to
individual actions. These execute permissions are also
assigned to specific users. As a result, the rights
management system can decide whether the logged-on user has
the right to perform a specific action. The rights management
system can be completely disabled <see text="Eplan.EplApi.ApplicationFramework.UserRights.CheckUserRights" cref="M:Eplan.EplApi.ApplicationFramework.UserRights.CheckUserRights" />,
or it can be set to a specific operating mode (logging on
with the current windows user). However, this operating mode
cannot be queried or set via API.
</summary>
            <seealso cref="!:QueryUserRights" />
        </member>
        <member name="M:Eplan.EplApi.ApplicationFramework.Internal.Module.unregisterModul">
            <summary>
For internal use only. 
</summary>
        </member>
        <member name="M:Eplan.EplApi.ApplicationFramework.Internal.Module.registerModul">
            <summary>
For internal use only. 
</summary>
        </member>
        <member name="M:Eplan.EplApi.ApplicationFramework.Internal.Module.exit">
            <summary>
For internal use only. 
</summary>
            <returns>
For internal use only. 
</returns>
        </member>
        <member name="M:Eplan.EplApi.ApplicationFramework.Internal.Module.initGui">
            <summary>
For internal use only. 
</summary>
            <returns>
For internal use only. 
</returns>
        </member>
        <member name="M:Eplan.EplApi.ApplicationFramework.Internal.Module.init">
            <summary>
For internal use only. 
</summary>
            <returns>
For internal use only. 
</returns>
        </member>
        <member name="M:Eplan.EplApi.ApplicationFramework.Internal.Module.#ctor">
            <summary>
For internal use only. 
</summary>
        </member>
        <member name="T:Eplan.EplApi.ApplicationFramework.Internal.Module">
            <summary>
For internal use only. 
</summary>
        </member>
        <member name="T:Eplan.EplApi.ApplicationFramework.AfLockingStep">
            <summary>
Used by LockingStep internally
</summary>
        </member>
        <member name="M:Eplan.EplApi.ApplicationFramework.EventManager.Send(System.String,Eplan.EplApi.ApplicationFramework.IEventParameter)">
            <summary>
Sends an event to the system.
</summary>
            <param name="strEventName">
Name of the event that is sent.
</param>
            <param name="pEventParameter">
Object containing parameters for this event.
</param>
            <returns>
Status of event processing. The Status is a result value of an event. The value is defined by the
catcher of the event. When more events are
called, the result is a bitwise or of every single result.
</returns>
            <example>Send the EventAusCSharpAddIn event with string parameters being passed (<see text="Eplan.EplApi.ApplicationFramework.EventParameterString" cref="T:Eplan.EplApi.ApplicationFramework.EventParameterString" />)
<use name="P8_API_Example_ApplicationFramework_EventManager_Example1.cs.txt" /></example>
        </member>
        <member name="T:Eplan.EplApi.ApplicationFramework.EventManager">
            <summary>
Class for sending events.
</summary>
        </member>
        <member name="M:Eplan.EplApi.ApplicationFramework.EventHandlerWrapper.InitializeLifetimeService">
            <summary>
This object should live "forever."
</summary>
            <returns>
Returns always <c>null</c>.
</returns>
        </member>
        <member name="M:Eplan.EplApi.ApplicationFramework.EventHandlerWrapper.LocallyEventHandlerFunction(Eplan.EplApi.ApplicationFramework.IEventParameter)">
            <summary>
This function of the local event handler is registered as a handler function of the remote event handler <see text="Eplan.EplApi.ApplicationFramework.EventHandler" cref="T:Eplan.EplApi.ApplicationFramework.EventHandler" />.
</summary>
            <param name="pIEventParameter">
Interface with parameters associated with the event.
</param>
        </member>
        <member name="F:Eplan.EplApi.ApplicationFramework.EventHandlerWrapper.EplanEventLocally">
            <summary>
Local event handler
</summary>
        </member>
        <member name="T:Eplan.EplApi.ApplicationFramework.EventHandlerWrapper">
            <summary>
Event handler to process EPLAN events in a remoting client. 
It is not possible to directly use the <see text="Eplan.EplApi.ApplicationFramework.EventHandler" cref="T:Eplan.EplApi.ApplicationFramework.EventHandler" /> in a remoting client! 
</summary>
            <example>Response to EPLAN events in a remoting client
<code lang="C#">
Eplan.EplApi.ApplicationFramework.EventHandler oEventHandler = new Eplan.EplApi.ApplicationFramework.EventHandler();
oEventHandler.SetEvent("onActionStart.String.*");
       
Eplan.EplApi.ApplicationFramework.EventHandlerWrapper oWrapper= new Eplan.EplApi.ApplicationFramework.EventHandlerWrapper();
oWrapper.EplanEventLocally += new Eplan.EplApi.ApplicationFramework.EventHandlerFunction(oWrapper_EventHandlerFunctionLocally);
          
oEventHandler.EplanEvent += new Eplan.EplApi.ApplicationFramework.EventHandlerFunction(oWrapper.LocallyEventHandlerFunction);
</code></example>
        </member>
        <member name="M:Eplan.EplApi.ApplicationFramework.IEplanEventsWrapper.EplanNameEventLocally(Eplan.EplApi.ApplicationFramework.IEventParameter,System.String)">
            <summary>
For internal use only. 
</summary>
        </member>
        <member name="M:Eplan.EplApi.ApplicationFramework.IEplanEventsWrapper.EplanEventLocally(Eplan.EplApi.ApplicationFramework.IEventParameter)">
            <summary>
For internal use only. 
</summary>
        </member>
        <member name="T:Eplan.EplApi.ApplicationFramework.IEplanEventsWrapper">
            <summary>
For internal use only. 
</summary>
        </member>
        <member name="M:Eplan.EplApi.ApplicationFramework.EventHandler.RaiseEventResult(Eplan.EplApi.ApplicationFramework.IEventParameter,System.String)">
            <summary>
For internal use only. 
</summary>
            <param name="pEventParameter">
For internal use only. 
</param>
        </member>
        <member name="M:Eplan.EplApi.ApplicationFramework.EventHandler.RaiseEvent(Eplan.EplApi.ApplicationFramework.IEventParameter,System.String)">
            <summary>
For internal use only. 
</summary>
            <param name="pEventParameter">
For internal use only. Not longer used, used for compilecompability
</param>
        </member>
        <member name="M:Eplan.EplApi.ApplicationFramework.EventHandler.SetEvent(System.String)">
            <summary>
Defines for which event the <see text="IEplanEvents" cref="T:Eplan.EplApi.ApplicationFramework.IEplanEvents" /> is raised.
</summary>
            <param name="strEventName">
Events with this name are edited through this event handler object. 
</param>
            <example>Define the event to respond to
<code lang="C#">
// Generate an event handler object
Eplan.EplApi.ApplicationFramework.EventHandler myHandler= new Eplan.EplApi.ApplicationFramework.EventHandler();
// The program should respond to this event
myHandler.SetEvent("onActionStart.String.*");
</code></example>
        </member>
        <member name="M:Eplan.EplApi.ApplicationFramework.EventHandler.Dispose">
            <summary>
Event handler is released. 
</summary>
        </member>
        <member name="M:Eplan.EplApi.ApplicationFramework.EventHandler.Finalize">
            <summary>
Event handler is released. 
</summary>
        </member>
        <member name="M:Eplan.EplApi.ApplicationFramework.EventHandler.#ctor(System.String)">
            <summary>
Creates a new object to handle events with the specified name.
</summary>
            <param name="strEventName">
Events with this name are edited through this event handler object. 
</param>
        </member>
        <member name="M:Eplan.EplApi.ApplicationFramework.EventHandler.#ctor">
            <summary>
Creates a new object to handle events. 
</summary>
        </member>
        <member name="E:Eplan.EplApi.ApplicationFramework.EventHandler.NameEvent">
            <summary>
This event is raised whenever an event with the desired name occurs in EPLAN.
</summary>
        </member>
        <member name="F:Eplan.EplApi.ApplicationFramework.EventHandler.EplanNameEventResult">
            <summary>
This event is raised whenever an event with the desired name occurs in EPLAN. The
original name of the event is also given. Additional a return value is supported.
</summary>
        </member>
        <member name="F:Eplan.EplApi.ApplicationFramework.EventHandler.EplanNameEvent">
            <summary>
This event is raised whenever an event with the desired name occurs in EPLAN. The
original name of the event is also given.
</summary>
        </member>
        <member name="F:Eplan.EplApi.ApplicationFramework.EventHandler.EplanEvent">
            <summary>
This event is raised whenever an event with the desired name occurs in EPLAN.
</summary>
        </member>
        <member name="T:Eplan.EplApi.ApplicationFramework.EventHandler">
            <summary>
Base class to handle events.
</summary>
            <remarks>
If you want to respond to EPLAN events from a remoting client,
you should use a local event handler object of the <see text="Eplan.EplApi.ApplicationFramework.EventHandlerWrapper" cref="!:Eplan::EplApi::ApplicationFramework::EventHandlerWrapper" /> type.
</remarks>
            <seealso text="Responding to EPLAN events" cref="!:Events" />
        </member>
        <member name="M:Eplan.EplApi.ApplicationFramework.IEplanEvents.EplanNameEvent(Eplan.EplApi.ApplicationFramework.IEventParameter,System.String)">
            <summary>
this is the function prototype called when an Eplan event is raised.
</summary>
            <param name="pIEventParameter">
The eventparameter for this event
</param>
            <param name="strNameOfEvent">
The original name of the event. This is useful when registered for more events with
wildcards.
</param>
        </member>
        <member name="M:Eplan.EplApi.ApplicationFramework.IEplanEvents.EplanEvent(Eplan.EplApi.ApplicationFramework.IEventParameter)">
            <summary>
this is the function prototype called when an Eplan event is raised.
</summary>
            <param name="pIEventParameter">
The eventparameter for this event
</param>
        </member>
        <member name="T:Eplan.EplApi.ApplicationFramework.IEplanEvents">
            <summary>
Declaration of the interface for EPLAN events. 
</summary>
        </member>
        <member name="T:Eplan.EplApi.ApplicationFramework.EventHandlerNameFunctionResult">
            <summary>
Functions of this type can be registered as event handlers in the class <see text="Eplan.EplApi.ApplicationFramewrok.EventHandler" cref="!:Eplan::EplApi::ApplicationFramewrok::EventHandler" />.
</summary>
            <param name="pEventParameter">
The interface can point to any event parameter type.   
</param>
            <param name="strNameOfEvent">
The original name of the send event. Can be useful when I was registered for an wildcard event, p.e. "Test*" 
</param>
            <returns>
the return value of your event. When there are more handlers the result value is the 
bitwise or of all results.
</returns>
        </member>
        <member name="T:Eplan.EplApi.ApplicationFramework.EventHandlerNameFunction">
            <summary>
Functions of this type can be registered as event handlers in the class <see text="Eplan.EplApi.ApplicationFramewrok.EventHandler" cref="!:Eplan::EplApi::ApplicationFramewrok::EventHandler" />.
</summary>
            <param name="pEventParameter">
The interface can point to any event parameter type.   
</param>
            <param name="strNameOfEvent">
The original name of the send event. Can be useful when I was registered for an wildcard event, p.e. "Test*" 
</param>
        </member>
        <member name="T:Eplan.EplApi.ApplicationFramework.EventHandlerFunction">
            <summary>
Functions of this type can be registered as event handlers in the class <see text="Eplan.EplApi.ApplicationFramewrok.EventHandler" cref="!:Eplan::EplApi::ApplicationFramewrok::EventHandler" />.
</summary>
            <param name="pEventParameter">
The interface can point to any event parameter type.   
</param>
        </member>
        <member name="P:Eplan.EplApi.ApplicationFramework.EventParameterString.String">
            <summary>
Event parameter of the String type.
</summary>
        </member>
        <member name="M:Eplan.EplApi.ApplicationFramework.EventParameterString.GetInternalParameter">
            <summary>
For internal use only. 
</summary>
            <returns>
For internal use only. 
</returns>
        </member>
        <member name="M:Eplan.EplApi.ApplicationFramework.EventParameterString.CreateFrom(Eplan.EplApi.ApplicationFramework.IEventParameter)">
            <summary>
Creates the specific EventParameterString object from the IEventParameter interface.
</summary>
            <param name="pIEventParameter">
The EventParameterString object is created from this interface.
This interface should point to an EventParameter object that is an EventParameterString.
</param>
        </member>
        <member name="M:Eplan.EplApi.ApplicationFramework.EventParameterString.Finalize">
            <summary>
Releases the object. 
</summary>
        </member>
        <member name="M:Eplan.EplApi.ApplicationFramework.EventParameterString.Dispose">
            <summary>
Releases the object. 
</summary>
        </member>
        <member name="M:Eplan.EplApi.ApplicationFramework.EventParameterString.#ctor(AfEvParString*)">
            <summary>
For internal use only. 
</summary>
            <param name="pAfEvParString">
For internal use only. 
</param>
        </member>
        <member name="M:Eplan.EplApi.ApplicationFramework.EventParameterString.#ctor(Eplan.EplApi.ApplicationFramework.IEventParameter)">
            <summary>
Creates a new event parameter object of the EventParameterString type from the base interface.
</summary>
            <param name="pIEventParameter">
This interface should point to an EventParameter object that is an EventParameterString.
</param>
        </member>
        <member name="M:Eplan.EplApi.ApplicationFramework.EventParameterString.#ctor">
            <summary>
Creates a new object.
</summary>
        </member>
        <member name="T:Eplan.EplApi.ApplicationFramework.EventParameterString">
            <summary>
Event parameter of the System::String data type
</summary>
        </member>
        <member name="M:Eplan.EplApi.ApplicationFramework.EventParameter.GetInternalParameter">
            <summary>
For internal use only. 
</summary>
            <returns>
For internal use only. 
</returns>
        </member>
        <member name="M:Eplan.EplApi.ApplicationFramework.EventParameter.Dispose">
            <summary>
For internal use only. 
</summary>
        </member>
        <member name="M:Eplan.EplApi.ApplicationFramework.EventParameter.Finalize">
            <summary>
For internal use only. 
</summary>
        </member>
        <member name="M:Eplan.EplApi.ApplicationFramework.EventParameter.#ctor(AfEventParameter*)">
            <summary>
For internal use only. 
</summary>
            <param name="pAfEventParameter">
For internal use only. 
</param>
        </member>
        <member name="T:Eplan.EplApi.ApplicationFramework.EventParameter">
            <summary>
Base class for event parameters 
</summary>
        </member>
        <member name="M:Eplan.EplApi.ApplicationFramework.IEventParameter.GetInternalParameter">
            <summary>
For internal use only. 
</summary>
            <returns>
For internal use only.
</returns>
        </member>
        <member name="T:Eplan.EplApi.ApplicationFramework.IEventParameter">
            <summary>
Base interface declaration for event parameters 
</summary>
        </member>
        <member name="M:Eplan.EplApi.ApplicationFramework.Internal.InternalEventHandler.onEvent(AfEventManagerMsg!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
For internal use only. 
</summary>
            <param name="msg">
For internal use only. 
</param>
        </member>
        <member name="M:Eplan.EplApi.ApplicationFramework.Internal.InternalEventHandler.Dispose">
            <summary>
For internal use only. 
</summary>
        </member>
        <member name="M:Eplan.EplApi.ApplicationFramework.Internal.InternalEventHandler.#ctor(Eplan.EplApi.ApplicationFramework.EventHandler,EString!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
For internal use only. 
</summary>
            <param name="pEventhandler">
For internal use only. 
</param>
            <param name="esEventName">
For internal use only. 
</param>
        </member>
        <member name="T:Eplan.EplApi.ApplicationFramework.Internal.InternalEventHandler">
            <summary>
For internal use only. 
</summary>
        </member>
    </members>
</doc>